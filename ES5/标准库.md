# 标准库

## Object

### Object()

`Object()`本身是一个函数，可以将任意值转换为对象

```js
var obj = Object();
// 等同于
var obj = Object(undefined);
var obj = Object(null);
```

如果要被转换的值为原始类型，`Object`会将其转换成对应的包装类型，如果要转换的值是对象，它总是返回该对象，即不用转换

```js
var obj = Object(1);
obj instanceof Object // true
obj instanceof Number // true

var obj = Object('foo');
obj instanceof Object // true
obj instanceof String // true

var obj = Object(true);
obj instanceof Object // true
obj instanceof Boolean // true
```

因此可以用`Object`来判断是否为对象

```js
var arr = [];
var obj = Object(arr); // 返回原数组
obj === arr // true

var value = {};
var obj = Object(value) // 返回原对象
obj === value // true

var fn = function () {};
var obj = Object(fn); // 返回原函数
obj === fn // true

function isObj(value){
  return value === Object(value);
}
```

### Object构造函数

```js
var obj = new Object();

//等同于

var obj = {};
```

`new Object(value)`中也可以传入值，和`Object(value)`相同，只不过在语义上有所差别。前者表示生成一个对象，它的值为`value`，后者表示将`value`转换为对象

### 静态方法

部署在`Object`对象自身的方法

#### Object.keys() && Object.getOwnPropertyNames()

`Object.keys`方法和`Object.getOwnPropertyNames`方法都用来遍历对象的属性。

`Object.keys()`和`Object.getOwnPropertyNames()`方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。

`Object.getOwnPropertyNames()`还可以遍历出不可枚举的属性，`Object.keys()`不可以

```js
var a = ['Hello', 'World'];

Object.keys(a) // ["0", "1"]
Object.getOwnPropertyNames(a) // ["0", "1", "length"]
```

#### Object.prototype.toString

`toString`方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。

数组、字符串、函数、Date对象都分别部署了自定义的`toString`方法

可以用来准确的判断数据类型

```js
Object.prototype.toString.call(value)
```

这样可以任意调用`Object.prototype.toString`方法

各种类型的返回结果

```
数值：返回[object Number]。
字符串：返回[object String]。
布尔值：返回[object Boolean]。
undefined：返回[object Undefined]。
null：返回[object Null]。
数组：返回[object Array]。
arguments 对象：返回[object Arguments]。
函数：返回[object Function]。
Error 对象：返回[object Error]。
Date 对象：返回[object Date]。
RegExp 对象：返回[object RegExp]。
其他对象：返回[object Object]。
```

利用这个可以写出比`typeof`更加准确的类型判断函数

```js
function checkType(value){
  var s = Object.prototype.toString.call(value);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
}
```

JavaScript中`match`函数方法返回的数组有三个属性：`input`、`index`和`lastIndex`。`Input` 属性包含整个的被查找字符串。`Index` 属性包含了在整个被查找字符串中匹配的子字符串的位置。`LastIndex` 属性包含了最后一次匹配中最后一个字符的下一个位置。如果没有设置全局标志 `g`，数组的0元素包含整个匹配，而第 1 到 n 元素包含了匹配中曾出现过的任一个**子匹配(在其中用过圆括号)**。这相当于没有设置全局标志的 `exec` 方法。如果设置了全局标志，元素0到n中包含所有匹配

#### Object.prototype.toLocaleString

返回值和`Object.prototype.toString`相同，用来留一个出口返回针对地域的某些特定的值.

## Array对象

### 创建

```js
var arr = [];

var arr = new Array()

var arr = new Array(3);
arr.length // 3

arr[0] // undefined
arr[1] // undefined
arr[2] // undefined

0 in arr // false
1 in arr // false
2 in arr // false
```

注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回`undefined`，但实际上该位置没有任何值。虽然可以取到`length`属性，但是取不到键名。

### 方法

#### 改变原数组

pop

`pop`方法用于删除数组的最后一个元素，并返回该元素

```js
[].pop()//undefined
```

push

`push`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度

shift

`shift`方法用于删除数组的第一个元素，并返回该元素

unshift

`unshift`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度

reverse

`reverse`方法用于颠倒数组中元素的顺序，返回改变后的数组

splice

`splice`方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素

```js
arr.splice(index, count_to_remove, addElement1, addElement2, ...)
```

sort

`sort`方法对数组成员进行排序，默认是按照字典顺序排序.

```js
[
  { name: "张三", age: 30 },
  { name: "李四", age: 24 },
  { name: "王五", age: 28  }
].sort(function (o1, o2) {
  return o1.age - o2.age;
})
// [
//   { name: "李四", age: 24 },
//   { name: "王五", age: 28 },
//   { name: "张三", age: 30 }
// ]
```

#### 不改变原数组

join

`join`方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。

```js
[undefined,null].join('#')//#
```

如果数组成员是`undefined`，`null`，或空位会被转换成空字符串

concat

`concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组.

slice

`slice`方法用于提取原数组的一部分，返回一个新数组.

```js
arr.slice(start_index,end_index);//左闭右开
```

也可以用来将类数组转换成数组

```js
Array.prototype.slice.call(arrayLike);
```

map

`map`方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。

```js
arr.map(function(item,index,arr){
  //当前成员,当前位置,数组本身
},arr)//花括号后的arr表示回调函数的this指向
//只有item是必须存在的
```

`map`方法不跳过`undefined`和`null`，但是会跳过空位，碰到空位不执行任何函数，直接跳过.

forEach

`forEach`方法与`map`方法很相似，也是遍历数组的所有成员，执行某种操作，但是`forEach`方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用`map`方法。

```js
arr.forEach(function(item,index,arr){
  //当前成员,当前位置,数组本身
},arr)//花括号后的arr表示回调函数的this指向
//只有item是必须存在的
```

filter

`filter`方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为`true`的成员组成一个新数组返回

```js
arr.filter(function(item,index,arr){
  //当前成员,当前位置,数组本身
},arr)//花括号后的arr表示回调函数的this指向
//只有item是必须存在的
```

some

`some`方法是只要有一个数组成员的返回值是`true`，则整个`some`方法的返回值就是`true`，否则`false`。

```js
arr.some(function(item,index,arr){
  //当前成员,当前位置,数组本身
},arr)//花括号后的arr表示回调函数的this指向
//只有item是必须存在的
```

every

`every`方法则是所有数组成员的返回值都是`true`，才返回`true`，否则`false`。

```js
arr.some(function(item,index,arr){
  //当前成员,当前位置,数组本身
},arr)//花括号后的arr表示回调函数的this指向
//只有item是必须存在的
```

reduce && reduceRight

`reduce`方法和`reduceRight`方法依次处理数组的每个成员，最终累计为一个值。

它们的差别是，`reduce`是从左到右处理（从第一个成员到最后一个成员），`reduceRight`则是从右到左（从最后一个成员到第一个成员），其他完全一样。

这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。

```
累积变量，默认为数组的第一个成员
当前变量，默认为数组的第二个成员
当前位置（从0开始）
原数组
```

这四个参数之中，只有前两个是必须的，后两个则是可选的。

indexOf && lastIndexOf

`indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。

`lastIndexOf`方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。

`indexOf`方法还可以接受第二个参数，表示搜索的开始位置。

如果数组中包含`NaN`，这两个方法不适用，即无法确定数组成员是否包含`NaN`

这是因为这两个方法内部，使用严格相等运算符`===`进行比较，而`NaN`是唯一一个不等于自身的值

## 包装对象

所谓「包装对象」，就是分别与数值、字符串、布尔值相对应的`Number`、`String`、`Boolean`三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。

```js
var r = new Number(123);
typeof r //object
```

如果不作为构造函数调用（即调用不加`new`），是将其它类型转换为`number`,`string`,`boolean`

### 原始类型的自动转换

原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，**在使用后立刻销毁**。

因为立即销毁，所以这个临时对象是只读的，无法进行修改，所以无法添加新属性。

```js
var str = 'abc';
str.length // 3

// 等同于
var strObj = new String(str)
// String {
//   0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"
// }
strObj.length // 3
```

`[[PrimitiveValue]]`保存字符串的原始值。这个`[[PrimitiveValue]]`内部属性，外部是无法调用，仅供`ValueOf`或`toString`这样的方法内部调用。

### Boolean对象

`false`对应的包装对象的实例,布尔运算结果是`true`

```js
if (new Boolean(false)) {
  console.log('true');
} // true

if (new Boolean(false).valueOf()) {
  console.log('true');
} // 无输出
```

上面代码的第一个例子之所以得到`true`，是因为`false`对应的包装对象实例是一个**对象**，进行逻辑运算时，被自动转化成布尔值`true`（因为所有对象对应的布尔值都是`true`）。而实例的`valueOf`方法，则返回实例对应的原始值，本例为`false`。

## Number

### 属性

```js
Number.POSITIVE_INFINITY：正的无限，指向Infinity。
Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。
Number.NaN：表示非数值，指向 NaN。
Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。
Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。
Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。
Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。
```

### 方法

#### toString

接受参数可以转为相应进制的字符串

```js
(10).toString(2) // "1010"
(10).toString(8) // "12"
(10).toString(16) // "a"
```

#### toFixed

`toFixed`方法的参数为指定的小数位数，有效范围为0到20，超出这个范围将抛出`RangeError`错误。

#### toExponential

`toExponential`方法的参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个`RangeError`。

#### toPrecision

`toExponential`方法的参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个`RangeError`。