# 浏览器环境

## 概述

### JavaScript 代码嵌入网页的方法

#### script标签:代码嵌入网页

`type` 指定脚本类型

- `text/javascript` 是默认值
- `application/javascript` 对于新式浏览器，建议这个值
- 也可以不写 `type`
- 写一个浏览器不认识的，就不会执行

#### script标签：加载外部脚本

```html
<script src="example.js"></script>
```

加载外部的脚步和直接添加代码块不能混用

```html
<script src="example.js">
  console.log('hello world');
</script>
```

`console.log` 会被忽略

为了防止攻击者篡改外部脚本，`script` 标签允许设置一个 `integrity` 属性，写入该外部脚本的Hash签名，用来验证脚本的一致性

```html
<script src="/assets/application.js"
  integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
</script>
```


#### 事件属性

```html
<div onclick="alert('Hello')"></div>
```

#### URL协议

URL支持 `javascript:` 协议，调用这个URL时，就会执行JavaScript代码。

```html
<a href="javascript:alert('Hello')"></a>
```

### script标签

#### 工作原理

正常的网页加载流程是这样的

1. 浏览器一边下载HTML网页，一边开始解析
2. 解析过程中，发现 `<script>` 标签
3. 暂停解析，网页渲染的控制权转交给JavaScript引擎
4. 如果 `<script>` 标签引用了外部脚本，就下载该脚本，否则就直接进行
5. 执行完毕，控制权交还给渲染引擎，恢复往下解析HTML网页

#### defer 属性

为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入 `defer` 属性

```html
<script src="a.js" defer></script>
<script src="b.js" defer></script>
```

`defer` 的运行流程如下

1. 浏览器开始解析HTML网页
2. 解析过程中，发现带有 `defer` 属性的 `script` 标签
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `script` 标签中的外部脚本
4. 浏览器完成解析HTML网页，此时再执行下载的脚本

使用 `defer` 加载的外部脚本不应该使用 `document.write` 方法

#### async

解决「阻塞效应」的一个方法是加入 `async`

`async` 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染

`async` 的运行流程如下

1. 浏览器开始解析HTML网页
2. 解析过程中，发现带有 `async` 属性的 `script` 标签
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `script` 标签中的外部文件
4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本
5. 脚本执行完毕，浏览器恢复解析 HTML 网页

`async` 无法保证脚本的执行顺序，一般来说，如果脚本没有依赖关系，用 `async` 属性，脚本之间有依赖关系，用 `defer` 属性，同时使用 `async` 和 `defer` 属性，后者不起作用，浏览器行为由 `async` 属性决定

#### 脚本的动态加载

```js
var script = document.createElement('script');
script.src = 'a.js';
document.head.appendChild(script);
```

#### 加载使用的协议

如果不指定协议，浏览器默认采用 HTTP 协议下载

如果要采用 HTTPS 下载，必须写明

```html
<script src="https://example.js"></script>
```

### 浏览器的组成

浏览器的核心是两部分：渲染引擎和 JavaScript 解释器

#### 渲染引擎

- Firefox : Gecko
- Safari : WebKit
- Chrome : Blink
- IE : Trident
- Edge : EdgeHTML

渲染引擎处理网页，通常分为四个阶段

1. 解析代码 ：HTML 代码解析为 DOM，CSS 代码解析为 CSSSOM 「CSS Object Model」
2. 对象合成 ：将 DOM 和 CSSOM 合成一棵渲染树 「render tree」
3. 布局 ：计算出渲染树的布局 「layout」
4. 绘制 ：将渲染树绘制到屏幕

往往第一步还没完成，第二部和第三部已经开始了。

#### 重流和重绘

渲染树转换为网页布局，称为「布局流」（flow）；布局显示到页面的这个过程，称为「绘制」（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。

重流一定会触发重绘，重绘不一定需要重流。

以下是一些优化技巧

- 读取 DOM 或者写入 DOM ，尽量写在一起，不要混杂
- 缓存 DOM 信息
- 不要一项一项地改变样式，而是使用CSS class一次性改变样式
- 使用document fragment操作DOM
- 动画时使用absolute定位或fixed定位，这样可以减少对其他元素的影响
- 只在必要时才显示元素
- 使用 `window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流
- 使用虚拟DOM（virtual DOM）库

#### JavaScript 引擎

早期的浏览器内部处理 JavaScript

1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
2. 对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。
3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。
4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。

现在都采用了即时编译，运行到哪一行代码翻译哪一行，把编译结果缓存。V8省略了翻译字节码的步骤，直接翻译为机器码

## window 对象

### 概述

在浏览器中，`window` 对象（注意，w为小写）指当前的浏览器窗口。它也是所有对象的顶层对象。

### window 属性

#### window.window，window.name

`window` 对象的 `window` 属性指向自身。

`window.name` 属性用于设置当前浏览器窗口的名字。该属性只能保存字符串，且当浏览器窗口关闭后，所保存的值就会消失。因此局限性比较大，但是与 `<iframe>` 窗口通信时，非常有用。

#### window.location

`window.location` 返回一个 `location` 对象，用于获取窗口当前的URL信息。它等同于 `document.location` 对象

#### window.closed，window.opener

`window.closed` 属性返回一个布尔值，表示窗口是否关闭。

`window.opener` 属性返回打开当前窗口的父窗口。如果当前窗口没有父窗口，则返回 `null`。

#### window.frames ，window.length

`window.frames` 属性返回一个类似数组的对象，成员为页面内所有框架窗口

`window.length` 属性返回当前网页包含的框架总数

#### window.screenX ，window.screenY

`window.screenX` 和 `window.screenY` 属性，返回浏览器窗口左上角相对于当前屏幕左上角（`(0, 0)`）的水平距离和垂直距离，单位为像素。

#### window.outerHeight，window.outerWidth

`window.outerHeight` 和 `window.outerWidth` 属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框，单位为像素。

#### window.pageXOffset，window.pageYOffset

`window.pageXOffset` 属性返回页面的水平滚动距离，`window.pageYOffset` 属性返回页面的垂直滚动距离，单位都为像素。

### navigator 对象

#### navigator.userAgent

`navigator.userAgent` 属性返回浏览器的User-Agent字符串，标示浏览器的厂商和版本信息。

用过 `userAgent` 属性识别浏览器不是一个好方法，但是 `userAgent` 可以大致准确地识别手机浏览器

```js
var ua = navigator.userAgent.toLowerCase();

if(/mobi/i.test(ua)){
  //手机浏览器
}else{
  //非手机浏览器
}
```

#### navigator.plugins

`navigator.plugins` 属性返回一个类似数组的对象，成员是浏览器安装的插件，比如Flash、ActiveX等。

#### navigator.platform

`navigator.platform` 属性返回用户的操作系统信息。

#### navigator.onLine

`navigator.onLine` 属性返回一个布尔值，表示用户当前在线还是离线。

#### navigator.geolocation

`navigator.geolocation` 返回一个Geolocation对象，包含用户地理位置的信息。

#### navigator.javaEnabled()，navigator.cookieEnabled

`javaEnabled` 方法返回一个布尔值，表示浏览器是否能运行Java Applet小程序

`cookieEnabled` 属性返回一个布尔值，表示浏览器是否能储存Cookie。

### window.screen 对象

`window.screen` 对象包含了显示设备的信息。

### window对象的方法

#### window.moveTo()，window.moveBy()

`window.moveTo` 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。

`window.moveBy` 方法将窗口移动到一个相对位置。它接受两个参数，分布是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。

#### window.scrollTo()，window.scrollBy()

`window.scrollTo` 方法用于将网页的指定位置，滚动到浏览器左上角。它的参数是相对于整张网页的横坐标和纵坐标。它有一个别名 `window.scroll` 。

`window.scrollBy` 方法用于将网页移动指定距离，单位为像素。它接受两个参数：向右滚动的像素，向下滚动的像素。

#### window.open(), window.close()

`window.open` 方法用于新建另一个浏览器窗口，并且返回该窗口对象。

`window.close` 方法用于关闭当前窗口，一般用来关闭window.open方法新建的窗口。

#### window.print()

`print` 方法会跳出打印对话框，同用户点击菜单里面的“打印”命令效果相同。

#### window.getComputedStyle()

`getComputedStyle` 方法接受一个HTML元素作为参数，返回一个包含该HTML元素的最终样式信息的对象

#### window.matchMedia()

`window.matchMedia` 方法用来检查CSS的mediaQuery语句

#### window.focus()

`focus` 方法会激活指定当前窗口，使其获得焦点。

#### window.getSelection()

`window.getSelection` 方法返回一个 `Selection` 对象，表示用户现在选中的文本。

### 多窗口操作

#### 窗口的引用

- top : 顶层窗口，即最上层的那个窗口
- parent : 父窗口
- self : 当前窗口，即自身

#### iframe 标签

对于 `iframe` 嵌入的窗口，`document.getElementById` 方法可以拿到该窗口的DOM节点，然后使用 `contentWindow` 属性获得 `iframe` 节点包含的 `window` 对象，或者使用 `contentDocument` 属性获得包含的 `document` 对象。

#### frames 属性

`window` 对象的 `frames` 属性返回一个类似数组的对象，成员是所有子窗口的 `window` 对象

需要注意的是，`window.frames` 每个成员的值，是框架内的窗口（即框架的 `window` 对象），而不是 `iframe` 标签在父窗口的DOM节点。如果要获取每个框架内部的DOM树，需要使用 `window.frames[0].document` 的写法。

另外，如果 `iframe` 元素设置了 `name` 或 `id` 属性，那么属性值会自动成为全局变量，并且可以通过 `window.frames` 属性引用，返回子窗口的 `window` 对象。

### 事件

#### load 事件和onload 属性

`load` 事件发生在文档在浏览器窗口加载完毕时。`window.onload` 属性可以指定这个事件的回调函数。

#### error 事件和 onerror 属性

浏览器脚本发生错误时，会触发 `window` 对象的 `error` 事件。我们可以通过 `window.onerror` 属性对该事件指定回调函数。

由于历史原因，`window `的 `error` 事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。

- 出错信息
- 出错脚本的网址
- 行号
- 列号
- 错误对象

老浏览器只支持前三个参数

### URL的编码/解码方法

#### encodeURI

`encodeURI` 方法的参数是一个字符串，代表整个URL。它会将元字符和语义字符之外的字符，都进行转义。

#### encodeURIComponent

`encodeURIComponent` 只转除了语义字符之外的字符，**元字符也会被转义**。因此，它的参数通常是URL的路径或参数值，而不是整个URL。

#### decodeURI

`decodeURI` 用于还原转义后的URL。它是 `encodeURI` 方法的逆运算。

#### decodeURIComponent

`decodeURIComponent` 用于还原转义后的URL片段。它是 `encodeURIComponent` 方法的逆运算。

#### alert()，prompt()，confirm()

`alert` 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。

`prompt` 方法弹出的对话框，在提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。

`confirm` 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户的意见。