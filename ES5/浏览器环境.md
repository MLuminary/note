# 浏览器环境

## 概述

### JavaScript 代码嵌入网页的方法

#### script标签:代码嵌入网页

`type` 指定脚本类型

- `text/javascript` 是默认值
- `application/javascript` 对于新式浏览器，建议这个值
- 也可以不写 `type`
- 写一个浏览器不认识的，就不会执行

#### script标签：加载外部脚本

```html
<script src="example.js"></script>
```

加载外部的脚步和直接添加代码块不能混用

```html
<script src="example.js">
  console.log('hello world');
</script>
```

`console.log` 会被忽略

为了防止攻击者篡改外部脚本，`script` 标签允许设置一个 `integrity` 属性，写入该外部脚本的Hash签名，用来验证脚本的一致性

```html
<script src="/assets/application.js"
  integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
</script>
```


#### 事件属性

```html
<div onclick="alert('Hello')"></div>
```

#### URL协议

URL支持 `javascript:` 协议，调用这个URL时，就会执行JavaScript代码。

```html
<a href="javascript:alert('Hello')"></a>
```

### script标签

#### 工作原理

正常的网页加载流程是这样的

1. 浏览器一边下载HTML网页，一边开始解析
2. 解析过程中，发现 `<script>` 标签
3. 暂停解析，网页渲染的控制权转交给JavaScript引擎
4. 如果 `<script>` 标签引用了外部脚本，就下载该脚本，否则就直接进行
5. 执行完毕，控制权交还给渲染引擎，恢复往下解析HTML网页

#### defer 属性

为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入 `defer` 属性

```html
<script src="a.js" defer></script>
<script src="b.js" defer></script>
```

`defer` 的运行流程如下

1. 浏览器开始解析HTML网页
2. 解析过程中，发现带有 `defer` 属性的 `script` 标签
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `script` 标签中的外部脚本
4. 浏览器完成解析HTML网页，此时再执行下载的脚本

使用 `defer` 加载的外部脚本不应该使用 `document.write` 方法

#### async

解决「阻塞效应」的一个方法是加入 `async`

`async` 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染

`async` 的运行流程如下

1. 浏览器开始解析HTML网页
2. 解析过程中，发现带有 `async` 属性的 `script` 标签
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `script` 标签中的外部文件
4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本
5. 脚本执行完毕，浏览器恢复解析 HTML 网页

`async` 无法保证脚本的执行顺序，一般来说，如果脚本没有依赖关系，用 `async` 属性，脚本之间有依赖关系，用 `defer` 属性，同时使用 `async` 和 `defer` 属性，后者不起作用，浏览器行为由 `async` 属性决定

#### 脚本的动态加载

```js
var script = document.createElement('script');
script.src = 'a.js';
document.head.appendChild(script);
```

#### 加载使用的协议

如果不指定协议，浏览器默认采用 HTTP 协议下载

如果要采用 HTTPS 下载，必须写明

```html
<script src="https://example.js"></script>
```

### 浏览器的组成

浏览器的核心是两部分：渲染引擎和 JavaScript 解释器

#### 渲染引擎

- Firefox : Gecko
- Safari : WebKit
- Chrome : Blink
- IE : Trident
- Edge : EdgeHTML

渲染引擎处理网页，通常分为四个阶段

1. 解析代码 ：HTML 代码解析为 DOM，CSS 代码解析为 CSSSOM 「CSS Object Model」
2. 对象合成 ：将 DOM 和 CSSOM 合成一棵渲染树 「render tree」
3. 布局 ：计算出渲染树的布局 「layout」
4. 绘制 ：将渲染树绘制到屏幕

往往第一步还没完成，第二部和第三部已经开始了。

#### 重流和重绘

渲染树转换为网页布局，称为「布局流」（flow）；布局显示到页面的这个过程，称为「绘制」（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。

重流一定会触发重绘，重绘不一定需要重流。

以下是一些优化技巧

- 读取 DOM 或者写入 DOM ，尽量写在一起，不要混杂
- 缓存 DOM 信息
- 不要一项一项地改变样式，而是使用CSS class一次性改变样式
- 使用document fragment操作DOM
- 动画时使用absolute定位或fixed定位，这样可以减少对其他元素的影响
- 只在必要时才显示元素
- 使用 `window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流
- 使用虚拟DOM（virtual DOM）库

#### JavaScript 引擎

早期的浏览器内部处理 JavaScript

1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
2. 对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。
3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。
4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。

现在都采用了即时编译，运行到哪一行代码翻译哪一行，把编译结果缓存。V8省略了翻译字节码的步骤，直接翻译为机器码