# 语法

## 基本语法

### 语句

JavaScript 程序的执行单位为行（line），也就是**一行一行**。一般情况下，每一行就是一个语句。


```js
var a = 1+3;
```

这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。

1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。

### 变量

在JS中,变量的声明与赋值是分开的两个步骤

JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。

```JS
var a = 1;
```

上面的代码实际上是

```js
var a;
a = 1;
```

这里强调一点

```js
var a = 1;
var a;
console.log(a);//1
```

如果用``var``声明一个已经存在的变量，是无效的。但是一旦进行了**赋值**操作，则会覆盖掉先前的值

### 区块

JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）

```js
{
  var a = 1;
}
console.log(a);//1
```

区块对于``var``命令不构成单独的作用域，与不使用区块没有任何区别。常见的区块``for``,``if``,``while``,``function``等

``function``中的区块是函数作用域

### 标签

JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置,通常与``continue``和``break``搭配

```js
top:
  for(var i=0;i<3;i++){
    if(i==1) continue top;
    console.log(i);
  }
//0
//2
```

## 数据类型

### 概念

ES5中有六种数据类型:数值(number),字符串(string),布尔值(boolean),undefined,null,对象(object)

数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。

对象是最复杂的数据类型，又可以分成三个子类型。

狭义的对象(object),数组(array),函数(function)

### null 和 undefined

两者还是有一些细微的差别

**null表示"没有对象"，即该处不应该有值** 转为数值时为0

```
1.作为函数的参数，表示为空
2.作为对象原型链的终点
3.为对象和值赋值为空
```

**undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义** 转为数值时为``NaN``

```
1.变量被声明了，但没有赋值时，就等于undefined。
2.调用函数时，应该提供的参数没有提供，该参数等于undefined。
3.对象没有赋值的属性，该属性的值为undefined。
4.函数没有返回值时，默认返回undefined。
```

### 布尔值

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。

```js
undefined
null
0
''或""
NaN
false
```

:heavy_exclamation_mark:注意

空对象和空数组也是``true``

## 数值

### 整数与浮点数

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。

```js
1 === 1.0 // true
```

这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算

```js
0.3/0.1//2.9999999999999996
0.1+0.2 === 0.3//false
```
#### 数值精度

精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，即-2^53到2^53

#### 数值范围

根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示。**正向溢出为``Infinity``,负向溢出为0**

#### 科学计数法

小数点前数字多于21位，小数点后的零多于5个就会自动转换为科学计数法


#### +0和-0

几乎所有场合+0和-0都是相等的,只有当+0和-0作为分母的时候才不相同

```js
(1/+0)//+Infinity
(1/-0)//-Infinity
```

这两个的结果是不想等的

#### NaN

``NaN``是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。

特点

```js
0/0 //NaN
NaN===NaN//false
NaN与任何数运算都是NaN
NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number
typeof NaN//'number'
```

### parseInt && parseFloat && Number

``parseInt``和``parseFloat``相似，用于将字符串转换成数值.特点如下

```
1.如果字符串头部有空格,空格会自动去除
2.是一个一个字符依次转换,如果碰到不能转换成数字的字符,就不在进行下去，返回已经转好的部分
3.如果字符串的第一次字符就不能转换成数字，则返回NaN
4.``parseFloat``可以转换科学技术法为十进制数字
5.遇到空字符串转为NaN
```

``Number``只要碰到字符串就返回``NaN``

### isNaN

判断一个值是否为``NaN``

但是，isNaN只对数值有效，**如果传入其他值，会被先转成数值**。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。

因此判断是否为``NaN``可以利用它与自身不等的特性

```js
function myIsNaN(value){
  return value!==value;
}
```

## 字符串

```js
'a
b
c'
// SyntaxError: Unexpected token ILLEGAL
```
上面代码将一个字符串分成三行，JavaScript 就会报错。

如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。

```js
var str = 'a\
b\
c';
str // abc
```

字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。**但是仅仅是相似而已，无法改变字符串中的单个字符** ``length``属性也是如此

### 字符集

每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。由于历史遗留问题,JavaScript只支持两个字节的字符，**四个字节的字符会识别成两个字符**

### Base64转码

```js
btoa()：任意值转为 Base64 编码
atob()：Base64 编码转为原来的值
```

但这两种方法不适合非ASCII码的字符,要加一个转码环节

```js
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}
```

## 对象

### 值传递

关于这个以前写过一篇[博文](http://hutchins.cn/2017/07/25/%E8%B0%88%E8%B0%88%E5%80%BC%E4%BC%A0%E9%80%92/)

### 表达式还是语句？

```js
{foo:123}
```

JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。

为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。

```js
({foo:123})
```

在``eval``中可以体现出差异

```js
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```

### 属性(键名)

可以采用点运算符和方运算符

:heavy_exclamation_mark:注意

数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。

方括号

```js
var str = 'foo';
var obj = {
  123: 2,
  foo: 6,
  str: 5
}
obj.123//错误
obj[123]//2
obj[str]//6
obj['str']//5
```

### 查看所有属性

```js
var obj = {
  123: 2,
  foo: 6,
  str: 5
}
Object.keys(obj);//(3) ["123", "foo", "str"]
```

### 删除属性

``delete``用于删除对象的属性

```js
var obj = {
  123: 2,
  foo: 6,
  str: 5
}
delete obj.foo
obj.foo //undefined
```

:heavy_exclamation_mark:注意

用``delete``删除一个属性,不会报错,而且还会返回true,因此不能根据``delete``返回的结果来判断是否有该属性

只有一种情况,``delete``返回``false``,那就是该属性存在，且不得删除

``delete``命令只能删除对象本身的属性，无法删除继承的属性


### in运算符

``in``运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。

```js
var obj = {
  123: 2,
  foo: 6,
  str: 5
}

'foo' in obj//true
```

但是``in``运算符无法判断哪些属性是自身的，哪些属性是继承的。他都会返回``true``

:coffee: ``for..in..``就是用来遍历对象的所有属性

### with

操作同一个对象的多个属性

```js
// 例一
var obj = {
  p1: 1,
  p2: 2,
};
with (obj) {
  p1 = 4;
  p2 = 5;
}
// 等同于
obj.p1 = 4;
obj.p2 = 5;

// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);
```

如果``with``区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。

这就造成一个弊端，就是绑定对象不明确,所以不推荐使用

## 数组

本质上就是对象

由于数组本质上就是一个对象,所以可以为数组添加属性，但是这并不影响``length``属性的值。因为``length``属性的值就是最大的数字键加1,如果这个数组没有数字键，那它的``lenth``保持为0

:heavy_exclamation_mark:注意
如果键名是超出范围的数值，也会被转换成字符串

### 空位

当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。

空位不会影响`length`属性

```js
var arr=[1,,3];//length 3 
var arr1=[1,2,3,]//length 3
```

数组的空位可以读取，为``undefined``，但是空位用遍历的是读取不到的，而``undefined``是可以读取出来的

使用``delete``删除一个数组成员，会形成空位，不会影响``length``

### 类数组对象

如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）

典型的类数组对象
```js
// arguments对象
function args() { return arguments }
var arrayLike = args('a', 'b');

arrayLike[0] // 'a'
arrayLike.length // 2
arrayLike instanceof Array // false

// DOM元素集
var elts = document.getElementsByTagName('h3');
elts.length // 3
elts instanceof Array // false

// 字符串
'abc'[1] // 'b'
'abc'.length // 3
'abc' instanceof Array // false
```

用数组的``slice``方法可以转换成真正的数组

```js
var arr = Array.prototype.slice.call(arrayLike);
```

还可以使用``call``方法使类数组使用数组的方法

```js
Array.prototype.forEach.call(arrayLike,funtion(){..});
```

但是这种方法要比原生的``forEach``要慢，因此还是推荐先转换成数组再用``forEach``