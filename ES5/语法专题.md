# 语法专题

## 单线程模式

JavaScript 只在一个线程上运行，也就是说同时只能进行一个任务，其他任务必须要排队.但是这不代表 JavaScript 只有一个线程，实际上 JavaScript 引擎有多个线程。

单线程模式带来很多问题，因为新的任务只能加在任务队列的末尾，如果排在前面的任务加载需要过长的时间，后面的所有任务都会在等待，造成浏览器失去响应，又称为「假死」

而且有的时候并不是因为计算量大，而是因为有的时候输入输出设备或者一些耗时的请求阻碍队列的正常的进行，此时CPU在闲着确还是出现了假死的现象

### 消息队列

为了避免以上说的情况，设计者设计了一个消息队列，也就是对于一些耗时的操作， JavaScript 引擎提供了一个消息队列，排在任务队列的最后。先优先处理相对简单的任务，等任务队列处理完成之后，再处理消息队列。

### Event Loop

所谓Event Loop机制，指的是一种内部循环，用来**一轮又一轮地处理消息队列之中的消息，即执行对应的回调函数**。

消息队列是一个先进先出的数据结构，按顺序动态添加处理消息队列中的任务

## 定时器

### setTimeout()

第一个参数是要执行的函数名，回调函数或者是代码，如果传入的是代码要用字符串的形式，因为引擎内部用 `eval`，第二个参数是推迟的时间单位为毫秒

```js
setTimeout(func|code,timeout)
```

`setTimeout` 还允许添加更多的参数，多余的参数会被传入回调函数中，这种方式IE9以下不支持

```js
setTimeout(function(a,b){
  console.log(a+b);
},1000,1,2)
```

如果还是想实现传参的话可以自定义一个函数

```js
setTimeout(function(){
  add(a,b);
},1000)
```

`setTimeout` 传入的回调函数如果是某个对象的方法，那么该方法中的 `this` 会指向全局对象

```js
function User(login) {
  this.login = login;
  this.sayHi = function() {
    console.log(this.login);
  }
}

var user = new User('John');

setTimeout(user.sayHi, 1000); //undefined
```

写在回调函数中即可

```js
setTimeout(function(){
  user.sayHi()
}, 1000);
```

也可用 `bind`

```js
setTimeout(user.sayHi.bind(this),1000)
```

HTML 5标准规定，`setTimeout` 的最短时间间隔是4毫秒。为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒。另外，如果笔记本电脑处于电池供电状态，Chrome和IE 9以上的版本，会将时间间隔切换到系统定时器，大约是15.6毫秒。

### setInterval()

`setInterval` 函数的用法与 `setTimeout` 完全一致，区别仅仅在于 `setInterval` 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。

`setInterval` 的时间间隔不是结束后的时间，而是开始后就开始算，假如 `delay` 时间设置的是 `1000ms` 假如这个任务执行了100ms，那么下次调用这个任务就是这个任务结束后的900ms执行，假如这个任务执行了1000ms那么后面的任务就在它执行后立马执行

为了确保两次执行的间隔之间相同，推荐使用 `setTimeout` 代替 `setInterval`

```js
var timer = setTimeout(function(){
  //do something
  var timer = setTimeout(arguments.callee,2000)
},2000)
```

也可以自定义一个函数来替代 `setInterval`

```js
function interval(func,delay){
  var interv = function(){
    //将func的this指向全局
    func.call(null);
    setTimeout(interv,delay)
  }
  setTimeout(interv,delay);
}
```

HTML 5标准规定，`setInterval` 的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒。

### clearTimeout() clearInterval()

`setTimeout` 和 `setInterval` 函数，都返回一个表示计数器编号的整数值，将该整数传入 `clearTimeout` 和 `clearInterval` 函数，就可以取消对应的定时器。

`setTimeout` 和 `setInterval` 返回的整数值是连续的。

利用这一点可以写一个函数取消当前所有的 `setTimeout()`

```js
(function() {
  var gid = setInterval(clearAllTimeouts, 0);

  function clearAllTimeouts() {
    //此id代表的数值为定义的定时器中最大的
    var id = setTimeout(function() {}, 0);
    while (id > 0) {
      if (id !== gid) {
        clearTimeout(id);
      }
      id--;
    }
  }
})();
```

运行上面代码后，实际上再设置任何 `setTimeout` 都无效了。

防抖动函数也可以利用 `setTimeout` 改写

```js
funciton debounce(func,delay){
  var timer = null;
  return function(){
    var context = this;
    var args = arguments;
    clearTimeout(timer);
    var timer = setTimeout(function(){
      func.apply(context,args);
    },delay)
  }
}
```

### 运行机制

`setTimeout` 和 `setInterval` 的运行机制是，将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。

### setTimeout(f,0)

#### 调整事件的执行顺序

用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，`keypress` 事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。

```js
document.getElementById('input-box').onkeypress = function(event) {
  this.value = this.value.toUpperCase();
}
```

上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以 `this.value` 取不到最新输入的那个字符。只有用 `setTimeout` 改写，上面的代码才能发挥作用。

```js
document.getElementById('my-ok').onkeypress = function() {
  var self = this;
  setTimeout(function() {
    self.value = self.value.toUpperCase();
  }, 0);
}
```

上面代码将代码放入 `setTimeout` 之中，就能使得它在浏览器接收到文本之后触发。

#### 分批处理耗时的任务

由于 `setTimeout(f,0)` 实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到 `setTimeout(f,0)` 里面执行。

```js
var div = document.getElementsByTagName('div')[0];

// 写法一
for (var i = 0xA00000; i < 0xFFFFFF; i++) {
  div.style.backgroundColor = '#' + i.toString(16);
}

// 写法二
var timer;
var i=0x100000;

function func() {
  timer = setTimeout(func, 0);
  div.style.backgroundColor = '#' + i.toString(16);
  if (i++ == 0xFFFFFF) clearTimeout(timer);
}

timer = setTimeout(func, 0);
```

上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器「堵塞」，**因为JavaScript执行速度远高于DOM**，会造成大量DOM操作「堆积」，而写法二就不会，这就是 `setTimeout(f, 0)` 的好处。

另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成 `setTimeout(highlightNext, 50)` 的样子，性能压力就会减轻。

### 正常任务和微任务

这时，需要区分两种任务：正常任务（task）与微任务（microtask）。它们的区别在于，「正常任务」在下一轮Event Loop执行，「微任务」在本轮Event Loop的所有任务结束后执行。

微任务主要是 `process.nextTick`和 Promise

正常任务为 

- setTimeout
- setInterval
- setImmediate
- I/O
- 各种事件（比如鼠标单击事件）的回调函数


```js
console.log(1);

setTimeout(function() {
  console.log(2);
}, 0);

Promise.resolve().then(function() {
  console.log(3);
}).then(function() {
  console.log(4);
});

console.log(5);

// 1
// 5
// 3
// 4
// 2
```

`setTimeout` 为正常任务，在下一轮执行，Promise 在队列结束后立马执行，所以 5 后先是 3 和 4 然后再是 2


