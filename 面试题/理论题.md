## HTML CSS

### 怎么让一个不定宽高的 DIV，垂直水平居中?

**使用Flex**

只需要在父盒子设置

```css
display: flex;
justify-content: center;
align-items: center;
```

**使用 CSS3 transform**

父盒子设置 `position:relative`
Div 设置:

```css
transform: translate(-50%，-50%);
position: absolute;top: 50%;
left: 50%;
```

**使用 display:table-cell 方法**

父盒子设置:

```css
display:table-cell;
text-align:center;
vertical-align:middle;
``` 

Div 设置: 

```css
display:inline-block;
vertical-align:middle;
```

### 如何清除浮动？

**首先说为什么要清除浮动**

浮动的出现一开始只是为了解决文字环绕问题，用浮动实现页面布局本来不是应该他干的事情，子元素设置浮动后，会脱离标准文档流，造成父元素高度塌陷

**清除浮动**

```js
.clearfloat{
  zoom:1;
}
.clearfloat:after{
  display:block;
  content:'';
  clear:both;
  height:0; 
  visibility:hidden;
}
```

### 了解 BFC 吗？

BFC(Block formatting context)直译为「块级格式化上下文」。它是一个独立的渲染区域，只有 Block-level box 参与， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。

BFC 布局规则 BFC 就是页面上的一个**隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此**。

### box-sizing 是什么

设置 css 盒模型为标准模型或 IE 模型

**标准盒模型** 的宽度只包含 `content`，**IE盒模型**包括 `border` 和 `padding`，`box-sizing` 可以设置三个值

- `content-box` : 默认值，只计算内容的宽度，标准盒模型
- `padding-box` : `padding` 计算入宽度内
- `border-box` : IE 盒模型

### CSS 隐藏元素的方式和区别

**display:none**

元素在页面上彻底消失，元素本来占有的空间会被其它元素占有，会导致浏览器的重排和重绘，也不会触发其中的事件

**visibility:hidden**

元素在页面消失，但是**本来占有的空间依旧会保留着**，所以只会导致浏览器**重绘**，也不会触发其中的事件

**opacity:0**

这种单单只是视觉上的隐藏，可以触发其中的事件，空间也会被保留

### 行内元素有哪些，块级元素有哪些?

行内元素：a、b、span、img、input、strong、select、label、em、button、textarea

块状元素: div、ul、li、dl、dt、dd、p、h1-h6、blockquote

### line-height 中需要注意的问题

`%` 和 `em` 是按照声明 `line-height` 处的 `font-size` 计算的，`line-height `为数字则是按每个元素继承或声明的 `font-size` 计算得到的

### 你做的网页在哪些浏览器测试过,这些浏览器的内核分别是什么?

- IE: trident 内核
- Firefox ： gecko 内核
- Safari:webkit 内核
- Opera: 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核
- Chrome:Blink( 基于 webkit ， Google 与 Opera Software 共同开发 )


## JS

### 数据类型都有哪些

String,Number,Object,Array,null,undefined,Boolean,Symbol

### js本地对象

Object,Function,Array,String,Boolean,Number,Date,RegExp,Error

### 准确的判断一个值的类型

```js
Object.prototype.toString.call(value)
```

调用 `Object `的 `toString` 方法

### 简要说下原型与原型链

在 JavaScript 中原型是一个 `prototype` 对象，用于表示类型之间的关系。

JavaScript 万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在 JavaScript 中是通过 `prototype` 对象指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。

`prototype` 是函数的属性，用来设置原型对象

`__proto__` 是对象的属性，值即为对象的原型

### `Object` 和 `Function` 的鸡和蛋的问题

先有 `Object.prototype` （原型链顶端），`Function.prototype` 继承 `Object.prototype` 而产生，最后，`Function` 和 `Object` 和其它构造函数继承 `Function.prototype` 而产生。

### 数组对空位的处理

`forEach()`, `filter()`, `reduce()`, `every()` 和 `some()` 都会跳过空位。

`map()` 会跳过空位，但会保留这个值

`join()` 和 `toString()` 会将空位视为 `undefined`，而 `undefined` 和 `null` 会被处理成空字符串。

ES6 中的方法都会将空位处理为 `undefined`

### 数组去重

```js
[...new Set(arr)]
```

### 两个实例对象的拷贝

如果要拷贝一个对象，要做到下面两件事件

- 确保拷贝后的对象，与原对象具有同样的原型
- 确保拷贝后的对象，与原对象具有同样的实例属性

```js
function copyObject(orig) {
  return Object.create(
    Object.getPrototypeOf(orig),
    Object.getOwnPropertyDescriptors(orig)
  );
}
```

**Object.create的原理**

```js
function(obj){
  function F(){};
  F.prototype = obj;
  return new F();
}
```

### 闭包

自己理解就是私有变量共有化

```js
let a = 12;
function A(){
  let a = 10;
  return function(){
    console.log(a);
  }
}

var B = A();
B();
```

### 事件流

事件捕获 -> 目标阶段 -> 事件冒泡

### 阻止冒泡和浏览器默认行为

```js
e = e || window.event
//阻止冒泡
e.stopPropagation() || e.cancelBubble

//阻止默认事件
e.preventDefault() || e.returnValue = false
```

## HTTP

### get 和 post 的区别

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 参数通过 URL 传递，POST 放在 Request body中。

### cookie

Cookie 的大小一般不超过 4kb

**Cookie** 的组成

- Cookie 的名字
- Cookie 的值
- 到期时间
- 所属的域名 （当前域名）
- 生效的路径 （默认当前网址）

### session

session 是为了维持客户端和服务器会话，通过 session 判断当前用户的身份，可以存储数组和对象，存活至浏览器关闭

session 机制是一种服务器端的机制，

[session的机制](http://justsee.iteye.com/blog/1570652)

### localStroage

不能设置过期时间，可存储数组和对象，存储在本地，相当于自己的 d 盘


### 一个页面输入URL到页面加载完成，这个过程都发生了什么？

1. 当发送一个 url 时，浏览器会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询，这能使浏览器获得请求对应的 IP
2. 浏览器与服务器通过 TCP 三次握手建立连接
3. 浏览器通过 HTTP 发送 Get 请求。远程服务器找到资源并通过 HTTP 返回该资源
4. 浏览器开始下载资源，并将其展现出来

### HTTP1.0 和 HTTP1.1 的区别

https://www.cnblogs.com/gofighting/p/5421890.html

### 关于跨域

https://segmentfault.com/a/1190000011145364

### TCP 与 UDP 的区别

![udp](images/udp.png)

**UDP服务器端算法的实现流程**

1. 调用 `socket()` 函数创建服务器端 UDP 套接字
2. 调用 `bind()` 函数将该 UDP 套接字绑定到本机的一个可用的端点地址
3. 调用 `recvfrom()` 函数从该 UDP 套接字接受来自远程客户端的数据并存入缓冲区，同时获得远程客户端的套接字端点地址并保存
4. 基于保存的远程客户端的套接字端点地址，调用 `sendTo()` 函数将缓冲区的数据从该套接字发送给远程客户端
5. 与客户交互完毕，调用 `close()` 函数将该 UDP 套接字关闭，释放系统所占的资源

**UDP客户端算法的实现流程**

1. 调用 `socket` 函数创建客户端 UDP 套接字
2. 找到期望与之通信的远程服务器的 IP 地址和协议端口号；然后再调用 `sendTo()` 函数将缓冲区的数据从 UDP 套接字发送给服务器端
3. 调用 `recvfrom()` 函数从该 UDP 套接字接受来自远程服务器端的数据并存入缓冲区
4. 调用 `close()` 将 UDP 套接字关闭，释放系统所占的资源

![tcp](images/tcp.png)

**TCP服务器端算法的实现流程**

1. 调用 `socket` 函数创建服务器端 TCP 主套接字
2. 调用 `bind` 函数将该套接字绑定到本机的一个可用端口
3. 调用 `listen` 函数将该套接字设置为被动模式，并设置等待队列的长度
4. 调用 `accept` 函数从该套接字上接受一个新客户连接请求，并在**连接成功**之后为该 TCP 连接**创建**一个新的从套接字
5. 基于新创建的套接字，调用 `recv` 接受来自客户端的数据并缓存
6. 基于新创建的套接字，调用 `send` 将缓冲区的数据发送给客户端
7. 与客户交互完毕，调用 `close` 关闭从套接字
8. 与所有客户交互完毕，调用 `close` 关闭主套接字

**TCP客户端算法的实现流程**

1. 调用 `socket` 函数创建客户端 TCP 套接字
2. 找到期望与之通信的服务器端套接字的端点地址，然后通过 `connect` 与远程服务器发起 TCP 连接请求
3. 在与服务器成功建立起 TCP 请求时调用 `send` 函数将缓冲区中的数据从套接字发送给远程服务端
4. 调用 `recv` 来接受服务器端发送的数据
5. 调用 `close` 关闭套接字


**TCP与UDP区别总结**

- TCP 面向连接，需要连接才能传送数据；UDP 不需要连接，即发送数据之前不需要连接
- TCP 提供可靠的服务，数据无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，但不可靠
- TCP 面向字节流；UDP面向报文，没有拥塞控制
- TCP 连接只能是点到点；UDP 支持一对一，多对多，多对一，一对多
- TCP 首部开销 20 字节；UDP 首部开销小，只有 8 个字节


 

